use crate::cve::Cve;
use crate::cve_exploit::CveExploit;
use crate::error::{DBError, DBResult};
use crate::exploit::Exploit;
use crate::pagination::ListResponse;
use crate::schema::{cve_exploit, cves, exploits};
use crate::DB;
use diesel::result::{DatabaseErrorKind, Error as DieselError};
use diesel::{ExpressionMethods, Insertable, MysqlConnection, QueryDsl, RunQueryDsl};
use serde::{Deserialize, Serialize};
#[cfg(feature = "openapi")]
use utoipa::IntoParams;

#[derive(Insertable, Debug)]
#[diesel(table_name = cve_exploit)]
pub struct CreateCveExploit {
  pub cve_id: String,
  pub exploit_id: Vec<u8>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct ExploitInfo {
  pub exploit: Exploit,
  pub cve: Option<Cve>,
  pub product: Option<Exploit>,
}

#[derive(Debug)]
pub struct CreateCveExploitByName {
  pub cve_id: String,
  pub vendor: String,
  pub product: String,
}

// 返回的CVE产品结构
#[derive(Debug, Serialize, Deserialize)]
pub struct CveExploitInfo {
  pub cve: Cve,
  pub exploit: Exploit,
}

#[cfg_attr(feature = "openapi", derive(IntoParams))]
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct QueryCveExploit {
  pub cve_id: Option<String>,
  pub vendor: Option<String>,
  pub product: Option<String>,
  pub size: Option<i64>,
  pub page: Option<i64>,
}

impl QueryCveExploit {
  // 查询参数过滤实现,免得写重复的过滤代码
  // https://github.com/diesel-rs/diesel/discussions/3468
  fn query<'a>(
    &'a self,
    _conn: &mut MysqlConnection,
    mut query: cve_exploit::BoxedQuery<'a, DB>,
  ) -> DBResult<cve_exploit::BoxedQuery<'a, DB>> {
    if let Some(id) = &self.cve_id {
      query = query.filter(cve_exploit::cve_id.eq(id));
    }
    Ok(query)
  }
  fn total(&self, conn: &mut MysqlConnection) -> DBResult<i64> {
    let query = self.query(conn, cve_exploit::table.into_boxed())?;
    // 统计查询全部，分页用
    Ok(
      query
        .select(diesel::dsl::count(cve_exploit::cve_id))
        .first::<i64>(conn)?,
    )
  }
}

impl CveExploit {
  // 创建CVE和产品关联
  pub fn create(conn: &mut MysqlConnection, args: &CreateCveExploit) -> DBResult<Self> {
    if let Err(err) = diesel::insert_into(cve_exploit::table)
      .values(args)
      .execute(conn)
    {
      // 重复了，说明已经存在弱点
      match err {
        DieselError::DatabaseError(DatabaseErrorKind::UniqueViolation, _) => {}
        _ => {
          return Err(DBError::DieselError { source: err });
        }
      }
    }
    // mysql 不支持 get_result，要再查一次得到插入结果
    Ok(
      cve_exploit::dsl::cve_exploit
        .filter(cve_exploit::cve_id.eq(&args.cve_id))
        .filter(cve_exploit::exploit_id.eq(&args.exploit_id))
        .first::<CveExploit>(conn)?,
    )
  }
  // 根据cve编号获取exp id列表
  pub fn query_by_cve(conn: &mut MysqlConnection, cve_id: String) -> DBResult<Vec<Vec<u8>>> {
    let args = QueryCveExploit {
      cve_id: Some(cve_id),
      vendor: None,
      product: None,
      size: None,
      page: None,
    };
    let query = args.query(conn, cve_exploit::table.into_boxed())?;
    let result = query
      .select(cve_exploit::exploit_id)
      .load::<Vec<u8>>(conn)?;
    Ok(result)
  }
  // 用来删除过期数据
  pub fn delete(
    conn: &mut MysqlConnection,
    cve_id: String,
    exploit_id: Vec<u8>,
  ) -> DBResult<usize> {
    Ok(
      diesel::delete(cve_exploit::table)
        .filter(cve_exploit::cve_id.eq(cve_id))
        .filter(cve_exploit::exploit_id.eq(exploit_id))
        .execute(conn)?,
    )
  }
  // 根据供应商，产品和CVE编号 返回CVE和产品信息
  pub fn query(
    conn: &mut MysqlConnection,
    args: &QueryCveExploit,
  ) -> DBResult<ListResponse<CveExploitInfo, QueryCveExploit>> {
    let total = args.total(conn)?;
    // 限制最大分页为20,防止拒绝服务攻击
    let page = args.page.unwrap_or(0);
    let size = std::cmp::min(args.size.to_owned().unwrap_or(10), 10);
    let result = {
      let exp_ids_query = args.query(conn, cve_exploit::table.into_boxed())?;
      let exp_ids = exp_ids_query
        .offset(page * size)
        .limit(size)
        .select(cve_exploit::exploit_id)
        .load::<Vec<u8>>(conn)?;
      // 联表查要把表写在前面，但是这样就用不了query了，所以先查处cve编号列表再eq_any过滤
      let query = cve_exploit::table
        .inner_join(cves::table)
        .inner_join(exploits::table)
        .into_boxed();
      query
        .filter(cve_exploit::exploit_id.eq_any(exp_ids))
        .load::<(CveExploit, Cve, Exploit)>(conn)?
        .into_iter()
        .map(|(_cp, c, p)| CveExploitInfo { cve: c, exploit: p })
        .collect::<Vec<_>>()
    };
    Ok(ListResponse::new(result, total, page, size, args.clone()))
  }
}
