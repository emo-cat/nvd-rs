use chrono::NaiveDateTime;

use serde::{Deserialize, Serialize};

mod date_format {
  use chrono::{NaiveDate, NaiveDateTime};
  use serde::{self, Deserialize, Deserializer, Serializer};

  pub(crate) const FORMAT: &str = "%Y-%m-%d";

  pub fn serialize<S>(date: &NaiveDateTime, serializer: S) -> Result<S::Ok, S::Error>
  where
    S: Serializer,
  {
    let s = date.to_string();
    serializer.serialize_str(&s)
  }

  pub fn deserialize<'de, D>(deserializer: D) -> Result<NaiveDateTime, D::Error>
  where
    D: Deserializer<'de>,
  {
    let s = String::deserialize(deserializer)?;
    if s.is_empty() {
      return Ok(NaiveDateTime::default());
    }
    match NaiveDate::parse_from_str(&s, FORMAT) {
      Ok(naive_datetime) => Ok(naive_datetime.and_hms_opt(0, 0, 0).unwrap_or_default()),
      Err(err) => Err(serde::de::Error::custom(err)),
    }
  }
}

#[derive(Debug, Deserialize, Serialize)]
struct ExploitDB {
  id: u32,
  file: String,
  description: String,
  #[serde(with = "date_format")]
  date_published: NaiveDateTime,
  author: String,
  r#type: String,
  platform: String,
  port: Option<u16>,
  #[serde(with = "date_format")]
  date_added: NaiveDateTime,
  #[serde(with = "date_format")]
  date_updated: NaiveDateTime,
  verified: u8,
  codes: Option<String>,
  tags: Option<String>,
  aliases: Option<String>,
  screenshot_url: Option<String>,
  application_url: Option<String>,
  source_url: Option<String>,
}
#[cfg(test)]
mod tests {

  #[test]
  fn it_works() {
    // let t = NaiveDate::parse_from_str("2010-11-11", "%Y-%m-%d").unwrap();
    // println!("{:?}", t.and_hms_opt(0, 0, 0));

    // let result = 2 + 22;
    // assert_eq!(result, 4);
  }
}
