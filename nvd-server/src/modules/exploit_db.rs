use crate::error::{DBError, DBResult};
use crate::modules::pagination::ListResponse;
use crate::modules::Exploit;
use crate::schema::exploits;
use crate::DB;
use chrono::NaiveDateTime;
use diesel::prelude::*;
use diesel::result::{DatabaseErrorKind, Error as DieselError};
use diesel::{Insertable, MysqlConnection, RunQueryDsl};
use serde::{Deserialize, Serialize};
use serde_json::Value;
#[cfg(feature = "openapi")]
use utoipa::IntoParams;

#[derive(Insertable)]
#[diesel(table_name = exploits)]
pub struct CreateExploit {
  pub id: Vec<u8>,
  pub name: String,
  pub description: Option<String>,
  pub source: String,
  pub path: String,
  pub meta: Value,
  pub verified: u8,
  pub created_at: NaiveDateTime,
  pub updated_at: NaiveDateTime,
}
#[cfg_attr(feature = "openapi", derive(IntoParams))]
#[derive(Debug, Serialize, Deserialize)]
pub struct QueryExploit {
  pub id: Option<Vec<u8>>,
  pub name: Option<String>,
  pub description: Option<String>,
  pub source: Option<String>,
  pub path: Option<String>,
  pub verified: Option<u8>,
  pub size: Option<i64>,
  pub page: Option<i64>,
}
impl QueryExploit {
  // 查询参数过滤实现,免得写重复的过滤代码
  // https://github.com/diesel-rs/diesel/discussions/3468
  fn query<'a>(
    &'a self,
    _conn: &mut MysqlConnection,
    mut query: exploits::BoxedQuery<'a, DB>,
  ) -> DBResult<exploits::BoxedQuery<'a, DB>> {
    // 如果有提供商名称，查询精准名称，返回该提供商旗下全部产品
    if let Some(source) = &self.source {
      query = query.filter(exploits::source.eq(source));
    }
    if let Some(name) = &self.name {
      query = query.filter(exploits::name.eq(name));
    }
    if let Some(verified) = &self.verified {
      query = query.filter(exploits::verified.eq(verified));
    }
    if let Some(path) = &self.path {
      query = query.filter(exploits::path.eq(path));
    }
    Ok(query)
  }
  fn total(&self, conn: &mut MysqlConnection) -> DBResult<i64> {
    let query = self.query(conn, exploits::table.into_boxed())?;
    // 统计查询全部，分页用
    Ok(
      query
        .select(diesel::dsl::count(exploits::id))
        .first::<i64>(conn)?,
    )
  }
}

impl Exploit {
  // 创建漏洞利用
  pub fn create(conn: &mut MysqlConnection, args: &CreateExploit) -> DBResult<Self> {
    if let Err(err) = diesel::insert_into(exploits::table)
      .values(args)
      .execute(conn)
    {
      // 重复了，说明已经存在漏洞利用
      match err {
        DieselError::DatabaseError(DatabaseErrorKind::UniqueViolation, _) => {}
        _ => {
          return Err(DBError::DieselError { source: err });
        }
      }
    }
    // mysql 不支持 get_result，要再查一次得到插入结果
    Ok(
      exploits::dsl::exploits
        .filter(exploits::name.eq(&args.name))
        .filter(exploits::source.eq(&args.source))
        .filter(exploits::path.eq(&args.path))
        .first::<Exploit>(conn)?,
    )
  }
  // 查询exploit信息
  pub fn query(conn: &mut MysqlConnection, args: &QueryExploit) -> DBResult<ListResponse<Exploit>> {
    let total = args.total(conn)?;
    // 限制最大分页为20,防止拒绝服务攻击
    let page = args.page.unwrap_or(0);
    let size = std::cmp::min(args.size.to_owned().unwrap_or(10), 10);
    let result = {
      let query = args.query(conn, exploits::table.into_boxed())?;
      query
        .order(exploits::id.desc())
        .offset(page * size)
        .limit(size)
        .load::<Exploit>(conn)?
    };
    Ok(ListResponse::new(result, total, page, size))
  }
}
